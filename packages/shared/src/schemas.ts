import { z } from 'zod'

// ============================================================================
// User Authentication Schemas
// ============================================================================

export const UserRoleEnum = z.enum(['ADMIN', 'USER'])
// Note: UserRole type is generated by Prisma from the enum in schema.prisma

export const UserSchema = z.object({
  id: z.string().cuid(),
  email: z.string().email(),
  name: z.string().nullable(),
  avatarUrl: z.string().url().nullable(),
  role: UserRoleEnum,
  createdAt: z.date(),
  lastLoginAt: z.date().nullable(),
})

export const SystemStatusSchema = z.object({
  initialized: z.boolean(),
  allowSignups: z.boolean(),
})

export const SettingSchema = z.object({
  key: z.string(),
  value: z.any(),
})

export const UpdateSettingSchema = z.object({
  value: z.any(),
})

// ============================================================================
// Storage Provider Schemas
// ============================================================================

export const StorageProviderEnum = z.enum([
  'google_drive_shared',    // Google Workspace Shared Drives (renamed from 'google_drive')
  'google_drive_my_drive',  // Personal Google Drive
  'google_cloud_storage',   // Google Cloud Storage (Service Account)
  's3',                     // Amazon S3
  'cloudflare_r2',          // Cloudflare R2 (S3-compatible)
  'digitalocean_spaces',    // DigitalOcean Spaces (S3-compatible)
])

export type StorageProvider = z.infer<typeof StorageProviderEnum>

// Provider categorization for UI and validation
export const OAuthProviders = ['google_drive_shared', 'google_drive_my_drive'] as const
export const ApiKeyProviders = ['s3', 'cloudflare_r2', 'digitalocean_spaces'] as const
export const ServiceAccountProviders = ['google_cloud_storage'] as const

export type OAuthProvider = (typeof OAuthProviders)[number]
export type ApiKeyProvider = (typeof ApiKeyProviders)[number]
export type ServiceAccountProvider = (typeof ServiceAccountProviders)[number]

// ============================================================================
// Storage Credential Schemas
// ============================================================================

export const CreateCredentialSchema = z.object({
  name: z.string().min(1, 'Name is required'),
  provider: StorageProviderEnum,
})

// Google Drive OAuth credentials (for both Shared Drives and My Drive)
export const GoogleDriveCredentialDataSchema = z.object({
  access_token: z.string(),
  refresh_token: z.string(),
  expiry_date: z.number(),
  token_type: z.string().default('Bearer'),
  scope: z.string(),
})

// S3 and S3-compatible credentials (S3, R2, Spaces)
export const S3CredentialDataSchema = z.object({
  access_key_id: z.string().min(1, 'Access Key ID is required'),
  secret_access_key: z.string().min(1, 'Secret Access Key is required'),
  region: z.string().default('us-east-1'),
  endpoint: z.string().url().optional(),       // Required for non-AWS S3 providers
  bucket: z.string().optional(),               // Can be pre-selected or chosen later
  force_path_style: z.boolean().default(false), // Required for some S3-compatible providers
  account_id: z.string().optional(),           // For Cloudflare R2
})

// Google Cloud Storage service account credentials
export const GCSCredentialDataSchema = z.object({
  type: z.literal('service_account'),
  project_id: z.string(),
  private_key_id: z.string(),
  private_key: z.string(),
  client_email: z.string().email(),
  client_id: z.string(),
  auth_uri: z.string().url(),
  token_uri: z.string().url(),
  auth_provider_x509_cert_url: z.string().url(),
  client_x509_cert_url: z.string().url(),
  universe_domain: z.string().optional(),
})

// Union type for all credential data schemas
export const CredentialDataSchema = z.union([
  GoogleDriveCredentialDataSchema,
  S3CredentialDataSchema,
  GCSCredentialDataSchema,
])

// ============================================================================
// Storage Destination Schemas
// ============================================================================

export const CreateDestinationSchema = z.object({
  credentialId: z.string().cuid(),
  provider: StorageProviderEnum,
  remoteId: z.string().min(1, 'Remote ID is required'),
  name: z.string().min(1, 'Name is required'),
  folderPath: z.string().optional(),
})

export const UpdateDestinationSchema = CreateDestinationSchema.partial().omit({
  provider: true,
  credentialId: true,
})

// ============================================================================
// Backup Job Schemas
// ============================================================================

export const RetentionTypeEnum = z.enum(['VERSION_COUNT', 'DAYS', 'HYBRID'])

export const CronExpressionSchema = z.string().regex(
  /^(\*|([0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9])|\*\/([0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9])) (\*|([0-9]|1[0-9]|2[0-3])|\*\/([0-9]|1[0-9]|2[0-3])) (\*|([1-9]|1[0-9]|2[0-9]|3[0-1])|\*\/([1-9]|1[0-9]|2[0-9]|3[0-1])) (\*|([1-9]|1[0-2])|\*\/([1-9]|1[0-2])) (\*|([0-6])|\*\/([0-6]))$/,
  'Invalid cron expression (use format: "minute hour day month weekday")'
)

const BaseBackupJobSchema = z.object({
  name: z.string().min(1, 'Name is required'),
  description: z.string().optional(),
  sourcePath: z.string().min(1, 'Source path is required'),
  destinationId: z.string().cuid(),
  credentialId: z.string().cuid(),
  schedule: CronExpressionSchema,
  retentionType: RetentionTypeEnum,
  retentionCount: z.number().int().positive().optional(),
  retentionDays: z.number().int().positive().optional(),
  namePattern: z.string().default('backup-{date}-{hash}'),
  enabled: z.boolean().default(true),
})

export const CreateBackupJobSchema = BaseBackupJobSchema.refine(
  (data) => {
    if (data.retentionType === 'VERSION_COUNT') {
      return data.retentionCount !== undefined
    }
    if (data.retentionType === 'DAYS') {
      return data.retentionDays !== undefined
    }
    if (data.retentionType === 'HYBRID') {
      return data.retentionCount !== undefined && data.retentionDays !== undefined
    }
    return true
  },
  {
    message: 'Retention policy requires appropriate count/days based on type',
  }
)

export const UpdateBackupJobSchema = BaseBackupJobSchema.partial()

// ============================================================================
// NAS Browser Schemas
// ============================================================================

export const BrowsePathSchema = z.object({
  path: z.string().default('/'),
})

export const NASFileSchema = z.object({
  name: z.string(),
  path: z.string(),
  type: z.enum(['file', 'directory']),
  size: z.number().optional(), // Only for files
  modified: z.date().optional(),
})

export const NASDirectorySchema = z.object({
  path: z.string(),
  items: z.array(NASFileSchema),
  totalSize: z.number().optional(),
  fileCount: z.number().optional(),
})

// ============================================================================
// Backup History Schemas
// ============================================================================

export const BackupStatusEnum = z.enum([
  'PENDING',
  'RUNNING',
  'UPLOADING',
  'ROTATING',
  'SUCCESS',
  'PARTIAL_SUCCESS',
  'FAILED',
  'CANCELLED',
])

export const TriggerSourceEnum = z.enum([
  'MANUAL',
  'SCHEDULED',
])

export const BackupHistoryQuerySchema = z.object({
  jobId: z.string().cuid().optional(),
  status: BackupStatusEnum.optional(),
  page: z.coerce.number().int().positive().default(1),
  pageSize: z.coerce.number().int().positive().max(100).default(20),
})

// ============================================================================
// Google Drive Specific Schemas
// ============================================================================

export const GoogleSharedDriveSchema = z.object({
  id: z.string(),
  name: z.string(),
  kind: z.string(),
  colorRgb: z.string().optional(),
  backgroundImageLink: z.string().url().optional(),
})

export const GoogleDriveFolderSchema = z.object({
  id: z.string(),
  name: z.string(),
  mimeType: z.string(),
  parents: z.array(z.string()).optional(),
  createdTime: z.string().optional(),
  modifiedTime: z.string().optional(),
})

// ============================================================================
// WebSocket Event Schemas
// ============================================================================

export const BackupProgressEventSchema = z.object({
  jobId: z.string(),
  historyId: z.string(),
  status: BackupStatusEnum,
  filesScanned: z.number(),
  filesUploaded: z.number(),
  filesFailed: z.number(),
  bytesUploaded: z.number(),
  currentFile: z.string().optional(),
  estimatedTimeRemaining: z.number().optional(), // seconds
  uploadSpeed: z.number().optional(), // bytes per second
})

export const QueueStatsEventSchema = z.object({
  waiting: z.number(),
  active: z.number(),
  completed: z.number(),
  failed: z.number(),
})

// ============================================================================
// Authentication Schemas
// ============================================================================

export const GoogleOAuthInitSchema = z.object({
  name: z.string().min(1, 'Credential name is required'),
})

export const GoogleOAuthCallbackSchema = z.object({
  code: z.string(),
  state: z.string(),
})

// ============================================================================
// API Response Schemas
// ============================================================================

export const SuccessResponseSchema = z.object({
  success: z.literal(true),
  data: z.any().optional(),
  message: z.string().optional(),
})

export const ErrorResponseSchema = z.object({
  success: z.literal(false),
  error: z.string(),
  details: z.any().optional(),
})

export const PaginatedResponseSchema = <T extends z.ZodTypeAny>(dataSchema: T) =>
  z.object({
    success: z.literal(true),
    data: z.array(dataSchema),
    pagination: z.object({
      total: z.number(),
      limit: z.number(),
      offset: z.number(),
      hasMore: z.boolean(),
    }),
  })
